## Status
To Do

## Story
**As a** developer,
**I want** to create and apply database migrations for the notification system,
**so that** the database schema is properly set up.

## Acceptance Criteria
1. Create migration for `notification_preferences` table
2. Create migration for `email_log` table
3. Create all necessary RLS policies
4. Create database functions and triggers
5. Test migrations in development environment
6. Document rollback procedures

## Migration Files

### Migration 1: Create Notification Preferences Table
```sql
-- migrations/20260106_create_notification_preferences.sql

-- Create notification_preferences table
create table if not exists public.notification_preferences (
  user_id uuid primary key references auth.users(id) on delete cascade,
  email_enabled boolean not null default true,
  order_updates boolean not null default true,
  billing_updates boolean not null default true,
  security_alerts boolean not null default true,
  marketing boolean not null default false,
  digest_mode text not null default 'immediate' check (digest_mode in ('immediate','daily','weekly')),
  quiet_hours_from time null,
  quiet_hours_to time null,
  updated_at timestamptz not null default now()
);

-- Enable RLS
alter table public.notification_preferences enable row level security;

-- RLS Policies
create policy "Users can view own preferences"
on public.notification_preferences
for select
using (auth.uid() = user_id);

create policy "Users can insert own preferences"
on public.notification_preferences
for insert
with check (auth.uid() = user_id);

create policy "Users can update own preferences"
on public.notification_preferences
for update
using (auth.uid() = user_id)
with check (auth.uid() = user_id);

-- Create function to auto-create default preferences
create or replace function public.create_default_notification_preferences()
returns trigger as $$
begin
  insert into public.notification_preferences (user_id)
  values (new.id)
  on conflict (user_id) do nothing;
  return new;
end;
$$ language plpgsql security definer;

-- Create trigger
create trigger on_auth_user_created_notification_prefs
  after insert on auth.users
  for each row execute function public.create_default_notification_preferences();

-- Create index
create index idx_notification_preferences_user_id on public.notification_preferences(user_id);

-- Backfill existing users
insert into public.notification_preferences (user_id)
select id from auth.users
on conflict (user_id) do nothing;

comment on table public.notification_preferences is 'User notification preferences for email notifications';
```

### Migration 2: Create Email Log Table
```sql
-- migrations/20260106_create_email_log.sql

-- Create email_log table
create table if not exists public.email_log (
  id bigserial primary key,
  user_id uuid references auth.users(id) on delete set null,
  recipient_email text not null,
  type text not null check (type in ('order_updates', 'billing_updates', 'security_alerts', 'marketing')),
  subject text not null,
  status text not null default 'queued' check (status in ('queued','sent','failed','skipped')),
  error_text text null,
  attempts int not null default 0,
  provider text not null default 'zoho_smtp',
  provider_response text null,
  created_at timestamptz not null default now(),
  sent_at timestamptz null
);

-- Create indexes for performance
create index idx_email_log_user_id on public.email_log(user_id);
create index idx_email_log_status on public.email_log(status);
create index idx_email_log_created_at on public.email_log(created_at desc);
create index idx_email_log_type on public.email_log(type);
create index idx_email_log_recipient on public.email_log(recipient_email);

-- Enable RLS
alter table public.email_log enable row level security;

-- RLS Policies
create policy "Admins can view all email logs"
on public.email_log
for select
using (
  exists (
    select 1 from public.profiles
    where profiles.id = auth.uid()
    and profiles.role = 'admin'
  )
);

create policy "Service role can insert email logs"
on public.email_log
for insert
with check (true);

create policy "Service role can update email logs"
on public.email_log
for update
using (true);

-- Function to check for duplicate emails
create or replace function public.is_duplicate_email(
  p_user_id uuid,
  p_type text,
  p_subject text,
  p_window_minutes int default 60
)
returns boolean as $$
begin
  return exists (
    select 1 from public.email_log
    where user_id = p_user_id
    and type = p_type
    and subject = p_subject
    and status in ('sent', 'queued')
    and created_at > now() - (p_window_minutes || ' minutes')::interval
  );
end;
$$ language plpgsql security definer;

-- Function to get email stats
create or replace function public.get_email_stats(
  p_user_id uuid default null,
  p_days int default 30
)
returns table (
  total_sent bigint,
  total_failed bigint,
  total_skipped bigint,
  success_rate numeric
) as $$
begin
  return query
  select
    count(*) filter (where status = 'sent') as total_sent,
    count(*) filter (where status = 'failed') as total_failed,
    count(*) filter (where status = 'skipped') as total_skipped,
    round(
      (count(*) filter (where status = 'sent')::numeric / 
       nullif(count(*) filter (where status in ('sent', 'failed'))::numeric, 0)) * 100,
      2
    ) as success_rate
  from public.email_log
  where (p_user_id is null or user_id = p_user_id)
  and created_at > now() - (p_days || ' days')::interval;
end;
$$ language plpgsql security definer;

comment on table public.email_log is 'Log of all email sending attempts';
comment on function public.is_duplicate_email is 'Check if an email was recently sent to prevent duplicates';
comment on function public.get_email_stats is 'Get email delivery statistics';
```

### Migration 3: Create Digest Queue Table (Optional)
```sql
-- migrations/20260106_create_digest_queue.sql

-- Create digest_queue table for batched notifications
create table if not exists public.digest_queue (
  id bigserial primary key,
  user_id uuid not null references auth.users(id) on delete cascade,
  type text not null check (type in ('order_updates', 'billing_updates', 'marketing')),
  subject text not null,
  content jsonb not null,
  digest_mode text not null check (digest_mode in ('daily', 'weekly')),
  scheduled_for timestamptz not null,
  sent boolean not null default false,
  created_at timestamptz not null default now()
);

-- Indexes
create index idx_digest_queue_user_id on public.digest_queue(user_id);
create index idx_digest_queue_scheduled on public.digest_queue(scheduled_for) where not sent;
create index idx_digest_queue_sent on public.digest_queue(sent);

-- Enable RLS
alter table public.digest_queue enable row level security;

-- RLS Policies
create policy "Service role can manage digest queue"
on public.digest_queue
for all
using (true);

comment on table public.digest_queue is 'Queue for batched email notifications (daily/weekly digests)';
```

### Rollback Scripts

```sql
-- rollback/20260106_rollback_notification_system.sql

-- Drop digest queue
drop table if exists public.digest_queue cascade;

-- Drop email log
drop function if exists public.get_email_stats cascade;
drop function if exists public.is_duplicate_email cascade;
drop table if exists public.email_log cascade;

-- Drop notification preferences
drop trigger if exists on_auth_user_created_notification_prefs on auth.users;
drop function if exists public.create_default_notification_preferences cascade;
drop table if exists public.notification_preferences cascade;
```

## Supabase CLI Commands

```bash
# Login to Supabase
supabase login

# Link to your project
supabase link --project-ref your-project-ref

# Create new migration
supabase migration new create_notification_system

# Apply migrations
supabase db push

# Reset database (development only!)
supabase db reset

# Generate TypeScript types
supabase gen types typescript --local > src/types/supabase.ts
```

## Manual Migration via Supabase Dashboard

1. Go to Supabase Dashboard â†’ SQL Editor
2. Copy and paste migration SQL
3. Click "Run"
4. Verify tables created in Table Editor
5. Test RLS policies

## Tasks / Subtasks
- [ ] Create migration files
- [ ] Test migrations locally
- [ ] Apply migrations to development environment
- [ ] Verify RLS policies work correctly
- [ ] Test triggers and functions
- [ ] Backfill existing users with default preferences
- [ ] Generate TypeScript types
- [ ] Document migration process
- [ ] Create rollback scripts
- [ ] Apply to production (after testing)

## Dev Notes
- Always test migrations in development first
- Use transactions for complex migrations
- Keep migrations idempotent (use `if not exists`)
- Document all schema changes
- Version control all migration files
- Test rollback procedures
- Consider data migration for existing users

## Verification Queries

```sql
-- Check if tables exist
select table_name 
from information_schema.tables 
where table_schema = 'public' 
and table_name in ('notification_preferences', 'email_log', 'digest_queue');

-- Check RLS policies
select tablename, policyname, permissive, roles, cmd, qual 
from pg_policies 
where schemaname = 'public' 
and tablename in ('notification_preferences', 'email_log');

-- Check triggers
select trigger_name, event_manipulation, event_object_table 
from information_schema.triggers 
where trigger_schema = 'public';

-- Check functions
select routine_name, routine_type 
from information_schema.routines 
where routine_schema = 'public' 
and routine_name like '%notification%' or routine_name like '%email%';

-- Count existing preferences
select count(*) from public.notification_preferences;

-- Check email log
select status, count(*) 
from public.email_log 
group by status;
```

## Testing Checklist
- [ ] Tables created successfully
- [ ] Indexes created
- [ ] RLS policies active
- [ ] Triggers working
- [ ] Functions executable
- [ ] Default preferences created for new users
- [ ] Existing users backfilled
- [ ] TypeScript types generated
- [ ] Rollback works correctly

## Dependencies
- Supabase project access
- Supabase CLI (optional)
- Database admin permissions

## Security Checklist
- [ ] RLS enabled on all tables
- [ ] Policies restrict access appropriately
- [ ] Functions use `security definer` where needed
- [ ] No sensitive data exposed
- [ ] Service role policies configured
