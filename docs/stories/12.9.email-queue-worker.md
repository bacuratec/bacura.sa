## Status
To Do

## Story
**As a** system architect,
**I want** a queue-based email sending system with background workers,
**so that** email sending doesn't block application requests and can be retried on failure.

## Acceptance Criteria
1. Email sending is asynchronous (queued)
2. Background worker processes queued emails
3. Failed emails are retried with exponential backoff
4. Worker runs on schedule (cron)
5. Dead letter queue for permanently failed emails
6. Monitoring and logging
7. Graceful shutdown handling

## Architecture

```
┌─────────────┐         ┌──────────────┐         ┌─────────────┐
│  App Event  │────────>│  email_log   │────────>│   Worker    │
│ (Order etc) │  Queue  │ status=queued│  Process│   (Cron)    │
└─────────────┘         └──────────────┘         └─────────────┘
                                                         │
                                                         ▼
                                                  ┌─────────────┐
                                                  │ Zoho SMTP   │
                                                  └─────────────┘
```

## Implementation

### 1. Queue Email Function

```javascript
// src/services/emailQueue.js
import { supabase } from '../lib/supabaseClient.js';

/**
 * Queue an email for sending
 * @param {Object} emailData - Email data
 * @returns {Promise<Object>} - Queue result
 */
export async function queueEmail({
  userId,
  recipientEmail,
  type,
  subject,
  templateData
}) {
  try {
    const { data, error } = await supabase
      .from('email_log')
      .insert({
        user_id: userId,
        recipient_email: recipientEmail,
        type,
        subject,
        status: 'queued',
        attempts: 0,
        metadata: templateData // Store template data as JSONB
      })
      .select()
      .single();

    if (error) throw error;

    console.log(`Email queued: ${data.id} for ${recipientEmail}`);
    return { success: true, queueId: data.id };

  } catch (error) {
    console.error('Error queueing email:', error);
    return { success: false, error: error.message };
  }
}

/**
 * Modified notification service to use queue
 */
export async function sendNotificationAsync({ userId, type, subject, data }) {
  // Check preferences first
  const canSend = await checkUserPreferences(userId, type);
  
  if (!canSend.allowed) {
    console.log(`Email skipped: ${canSend.reason}`);
    return { success: false, reason: canSend.reason };
  }

  // Get user email
  const { data: user } = await supabase
    .from('profiles')
    .select('email, full_name')
    .eq('id', userId)
    .single();

  if (!user?.email) {
    return { success: false, reason: 'no_email' };
  }

  // Queue the email instead of sending immediately
  return await queueEmail({
    userId,
    recipientEmail: user.email,
    type,
    subject,
    templateData: { ...data, userName: user.full_name }
  });
}
```

### 2. Email Worker

```javascript
// workers/emailWorker.js
import { supabase } from '../lib/supabaseClient.js';
import { sendEmail } from '../services/emailService.js';
import { emailTemplates } from '../templates/emailTemplates.js';

const MAX_ATTEMPTS = 3;
const BATCH_SIZE = 10;

/**
 * Process queued emails
 */
export async function processEmailQueue() {
  console.log('[EmailWorker] Starting email queue processing...');

  try {
    // Fetch queued emails
    const { data: queuedEmails, error } = await supabase
      .from('email_log')
      .select('*')
      .eq('status', 'queued')
      .lt('attempts', MAX_ATTEMPTS)
      .order('created_at', { ascending: true })
      .limit(BATCH_SIZE);

    if (error) throw error;

    if (!queuedEmails || queuedEmails.length === 0) {
      console.log('[EmailWorker] No emails in queue');
      return { processed: 0, success: 0, failed: 0 };
    }

    console.log(`[EmailWorker] Processing ${queuedEmails.length} emails`);

    let successCount = 0;
    let failedCount = 0;

    // Process each email
    for (const emailLog of queuedEmails) {
      const result = await processEmail(emailLog);
      if (result.success) {
        successCount++;
      } else {
        failedCount++;
      }
    }

    console.log(`[EmailWorker] Completed: ${successCount} success, ${failedCount} failed`);
    
    return {
      processed: queuedEmails.length,
      success: successCount,
      failed: failedCount
    };

  } catch (error) {
    console.error('[EmailWorker] Error processing queue:', error);
    return { processed: 0, success: 0, failed: 0, error: error.message };
  }
}

/**
 * Process a single email
 */
async function processEmail(emailLog) {
  const { id, recipient_email, type, subject, metadata, attempts } = emailLog;

  try {
    console.log(`[EmailWorker] Processing email ${id} to ${recipient_email}`);

    // Generate email content from template
    const template = getEmailTemplate(type, metadata);

    // Send email
    const result = await sendEmail({
      to: recipient_email,
      subject: template.subject || subject,
      html: template.html,
      text: template.text
    });

    if (result.success) {
      // Update status to sent
      await supabase
        .from('email_log')
        .update({
          status: 'sent',
          sent_at: new Date().toISOString(),
          provider_response: result.response,
          attempts: attempts + 1
        })
        .eq('id', id);

      console.log(`[EmailWorker] ✓ Email ${id} sent successfully`);
      return { success: true };

    } else {
      // Update attempt count and error
      const newAttempts = attempts + 1;
      const newStatus = newAttempts >= MAX_ATTEMPTS ? 'failed' : 'queued';

      await supabase
        .from('email_log')
        .update({
          status: newStatus,
          error_text: result.error,
          attempts: newAttempts
        })
        .eq('id', id);

      console.log(`[EmailWorker] ✗ Email ${id} failed (attempt ${newAttempts}/${MAX_ATTEMPTS})`);
      return { success: false, error: result.error };
    }

  } catch (error) {
    console.error(`[EmailWorker] Error processing email ${id}:`, error);

    // Update error status
    await supabase
      .from('email_log')
      .update({
        status: 'failed',
        error_text: error.message,
        attempts: attempts + 1
      })
      .eq('id', id);

    return { success: false, error: error.message };
  }
}

/**
 * Get email template by type
 */
function getEmailTemplate(type, data) {
  const templates = {
    'order_updates': emailTemplates.orderUpdate,
    'billing_updates': emailTemplates.billingUpdate,
    'security_alerts': emailTemplates.securityAlert,
    'marketing': emailTemplates.marketing
  };

  const templateFn = templates[type];
  return templateFn ? templateFn(data) : { subject: '', html: '', text: '' };
}

/**
 * Retry failed emails (with exponential backoff)
 */
export async function retryFailedEmails() {
  console.log('[EmailWorker] Checking for failed emails to retry...');

  try {
    // Get failed emails that haven't exceeded max attempts
    const { data: failedEmails, error } = await supabase
      .from('email_log')
      .select('*')
      .eq('status', 'failed')
      .lt('attempts', MAX_ATTEMPTS)
      .order('created_at', { ascending: true })
      .limit(5);

    if (error) throw error;

    if (!failedEmails || failedEmails.length === 0) {
      console.log('[EmailWorker] No failed emails to retry');
      return { retried: 0 };
    }

    // Reset status to queued for retry
    for (const email of failedEmails) {
      await supabase
        .from('email_log')
        .update({ status: 'queued' })
        .eq('id', email.id);
    }

    console.log(`[EmailWorker] Queued ${failedEmails.length} failed emails for retry`);
    return { retried: failedEmails.length };

  } catch (error) {
    console.error('[EmailWorker] Error retrying failed emails:', error);
    return { retried: 0, error: error.message };
  }
}

/**
 * Clean up old email logs (retention policy)
 */
export async function cleanupOldLogs(daysToKeep = 90) {
  console.log(`[EmailWorker] Cleaning up logs older than ${daysToKeep} days...`);

  try {
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - daysToKeep);

    const { error } = await supabase
      .from('email_log')
      .delete()
      .lt('created_at', cutoffDate.toISOString())
      .in('status', ['sent', 'skipped']); // Keep failed for analysis

    if (error) throw error;

    console.log('[EmailWorker] Old logs cleaned up successfully');
    return { success: true };

  } catch (error) {
    console.error('[EmailWorker] Error cleaning up logs:', error);
    return { success: false, error: error.message };
  }
}
```

### 3. Cron Job Setup (Node-Cron)

```javascript
// workers/scheduler.js
import cron from 'node-cron';
import { processEmailQueue, retryFailedEmails, cleanupOldLogs } from './emailWorker.js';

/**
 * Start email worker scheduler
 */
export function startEmailWorker() {
  console.log('[Scheduler] Starting email worker scheduler...');

  // Process queue every minute
  cron.schedule('* * * * *', async () => {
    console.log('[Scheduler] Running email queue processor...');
    await processEmailQueue();
  });

  // Retry failed emails every 5 minutes
  cron.schedule('*/5 * * * *', async () => {
    console.log('[Scheduler] Running failed email retry...');
    await retryFailedEmails();
  });

  // Cleanup old logs daily at 2 AM
  cron.schedule('0 2 * * *', async () => {
    console.log('[Scheduler] Running log cleanup...');
    await cleanupOldLogs(90);
  });

  console.log('[Scheduler] Email worker scheduler started');
}

/**
 * Graceful shutdown
 */
export function stopEmailWorker() {
  console.log('[Scheduler] Stopping email worker scheduler...');
  cron.getTasks().forEach(task => task.stop());
  console.log('[Scheduler] Email worker scheduler stopped');
}
```

### 4. Main Worker Process

```javascript
// workers/index.js
import { startEmailWorker, stopEmailWorker } from './scheduler.js';

// Start worker
startEmailWorker();

// Graceful shutdown
process.on('SIGTERM', () => {
  console.log('SIGTERM received, shutting down gracefully...');
  stopEmailWorker();
  process.exit(0);
});

process.on('SIGINT', () => {
  console.log('SIGINT received, shutting down gracefully...');
  stopEmailWorker();
  process.exit(0);
});

console.log('Email worker process started');
```

### 5. Alternative: Supabase Edge Function (Scheduled)

```typescript
// supabase/functions/email-worker/index.ts
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

const supabase = createClient(
  Deno.env.get('SUPABASE_URL') ?? '',
  Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
);

serve(async (req) => {
  try {
    // Fetch queued emails
    const { data: queuedEmails } = await supabase
      .from('email_log')
      .select('*')
      .eq('status', 'queued')
      .lt('attempts', 3)
      .limit(10);

    // Process emails
    let processed = 0;
    for (const email of queuedEmails || []) {
      // Send email logic here
      processed++;
    }

    return new Response(
      JSON.stringify({ success: true, processed }),
      { headers: { 'Content-Type': 'application/json' } }
    );

  } catch (error) {
    return new Response(
      JSON.stringify({ success: false, error: error.message }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    );
  }
});
```

### 6. Package.json Scripts

```json
{
  "scripts": {
    "worker:start": "node workers/index.js",
    "worker:dev": "nodemon workers/index.js",
    "worker:pm2": "pm2 start workers/index.js --name email-worker"
  },
  "dependencies": {
    "node-cron": "^3.0.3"
  },
  "devDependencies": {
    "nodemon": "^3.0.2"
  }
}
```

### 7. PM2 Ecosystem File

```javascript
// ecosystem.config.js
module.exports = {
  apps: [
    {
      name: 'email-worker',
      script: './workers/index.js',
      instances: 1,
      autorestart: true,
      watch: false,
      max_memory_restart: '1G',
      env: {
        NODE_ENV: 'production'
      },
      error_file: './logs/email-worker-error.log',
      out_file: './logs/email-worker-out.log',
      log_date_format: 'YYYY-MM-DD HH:mm:ss Z'
    }
  ]
};
```

## Database Schema Update

```sql
-- Add metadata column to email_log for storing template data
alter table public.email_log 
add column if not exists metadata jsonb null;

-- Add index for queued emails
create index if not exists idx_email_log_queued 
on public.email_log(status, attempts, created_at) 
where status = 'queued';
```

## Usage Example

```javascript
// In your order service
import { sendNotificationAsync } from '../services/emailQueue.js';

async function updateOrderStatus(orderId, newStatus) {
  // Update order
  await updateOrder(orderId, newStatus);

  // Queue notification (non-blocking)
  await sendNotificationAsync({
    userId: order.user_id,
    type: 'order_updates',
    subject: `تحديث الطلب #${orderId}`,
    data: {
      orderId,
      status: newStatus,
      message: 'تم تحديث حالة طلبك'
    }
  });

  // Return immediately without waiting for email
  return { success: true };
}
```

## Tasks / Subtasks
- [ ] Install node-cron package
- [ ] Create email worker module
- [ ] Create scheduler module
- [ ] Add metadata column to email_log
- [ ] Implement queue processing logic
- [ ] Implement retry logic with exponential backoff
- [ ] Add cleanup job for old logs
- [ ] Set up PM2 for production
- [ ] Add monitoring and alerting
- [ ] Test worker under load
- [ ] Document deployment process

## Dev Notes
- Use PM2 for production deployment
- Monitor worker health and performance
- Set up alerts for high failure rates
- Consider using Redis for better queue management at scale
- Implement dead letter queue for permanent failures
- Add metrics (processed/minute, success rate, etc.)

## Monitoring

```javascript
// Add to worker for metrics
let metrics = {
  processed: 0,
  success: 0,
  failed: 0,
  lastRun: null
};

// Expose metrics endpoint
app.get('/metrics', (req, res) => {
  res.json(metrics);
});
```

## Testing Checklist
- [ ] Emails are queued correctly
- [ ] Worker processes queued emails
- [ ] Failed emails are retried
- [ ] Max attempts respected
- [ ] Cleanup job works
- [ ] Graceful shutdown works
- [ ] Worker restarts on crash
- [ ] Performance acceptable under load

## Dependencies
- node-cron
- pm2 (production)
- @supabase/supabase-js
