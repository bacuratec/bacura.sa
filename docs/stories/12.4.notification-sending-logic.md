## Status
To Do

## Story
**As a** system,
**I want** to respect user preferences before sending emails,
**so that** users only receive notifications they want.

## Acceptance Criteria
1. Check user preferences before sending any email
2. Respect email_enabled flag (master switch)
3. Respect individual notification type preferences
4. Respect quiet hours settings
5. Implement digest mode (immediate, daily, weekly)
6. Prevent duplicate notifications
7. Log all sending attempts

## Notification Sending Logic

```javascript
// src/services/notificationService.js
import { supabase } from '../lib/supabaseClient';
import { sendEmail } from './emailService';
import { emailTemplates } from '../templates/emailTemplates';

/**
 * Main function to send notification
 * @param {Object} params - Notification parameters
 * @param {string} params.userId - User ID
 * @param {string} params.type - Notification type (order_updates, billing_updates, security_alerts, marketing)
 * @param {string} params.subject - Email subject
 * @param {Object} params.data - Template data
 * @returns {Promise<Object>} - Send result
 */
export async function sendNotification({ userId, type, subject, data }) {
  try {
    // Step 1: Get user preferences
    const { data: preferences, error: prefError } = await supabase
      .from('notification_preferences')
      .select('*')
      .eq('user_id', userId)
      .single();

    if (prefError) {
      console.error('Error fetching preferences:', prefError);
      return { success: false, reason: 'preferences_error', error: prefError };
    }

    // Step 2: Check if email is enabled globally
    if (!preferences.email_enabled) {
      await logEmail(userId, type, subject, 'skipped', 'Email disabled globally');
      return { success: false, reason: 'email_disabled' };
    }

    // Step 3: Check if this notification type is enabled
    const typeMapping = {
      'order_updates': preferences.order_updates,
      'billing_updates': preferences.billing_updates,
      'security_alerts': preferences.security_alerts,
      'marketing': preferences.marketing
    };

    if (!typeMapping[type]) {
      await logEmail(userId, type, subject, 'skipped', `${type} disabled`);
      return { success: false, reason: 'type_disabled' };
    }

    // Step 4: Check quiet hours (skip for security_alerts)
    if (type !== 'security_alerts' && isInQuietHours(preferences)) {
      await logEmail(userId, type, subject, 'skipped', 'In quiet hours');
      return { success: false, reason: 'quiet_hours' };
    }

    // Step 5: Check for duplicates
    const isDuplicate = await checkDuplicateEmail(userId, type, subject);
    if (isDuplicate) {
      await logEmail(userId, type, subject, 'skipped', 'Duplicate email');
      return { success: false, reason: 'duplicate' };
    }

    // Step 6: Get user email
    const { data: user, error: userError } = await supabase
      .from('profiles')
      .select('email, full_name')
      .eq('id', userId)
      .single();

    if (userError || !user.email) {
      await logEmail(userId, type, subject, 'failed', 'User email not found');
      return { success: false, reason: 'no_email' };
    }

    // Step 7: Check digest mode
    if (preferences.digest_mode !== 'immediate' && type !== 'security_alerts') {
      // Queue for digest (implement later)
      await queueForDigest(userId, type, subject, data, preferences.digest_mode);
      return { success: true, reason: 'queued_for_digest' };
    }

    // Step 8: Generate email content
    const template = getTemplate(type, { ...data, userName: user.full_name });

    // Step 9: Send email
    const result = await sendEmail({
      to: user.email,
      subject: template.subject || subject,
      html: template.html
    });

    // Step 10: Log the result
    if (result.success) {
      await logEmail(userId, type, subject, 'sent', null, result.response, user.email);
      return { success: true, messageId: result.messageId };
    } else {
      await logEmail(userId, type, subject, 'failed', result.error, null, user.email);
      return { success: false, reason: 'send_failed', error: result.error };
    }

  } catch (error) {
    console.error('Notification sending error:', error);
    await logEmail(userId, type, subject, 'failed', error.message);
    return { success: false, reason: 'exception', error: error.message };
  }
}

/**
 * Check if current time is in quiet hours
 */
function isInQuietHours(preferences) {
  if (!preferences.quiet_hours_from || !preferences.quiet_hours_to) {
    return false;
  }

  const now = new Date();
  const currentTime = now.getHours() * 60 + now.getMinutes();
  
  const [fromHour, fromMin] = preferences.quiet_hours_from.split(':').map(Number);
  const [toHour, toMin] = preferences.quiet_hours_to.split(':').map(Number);
  
  const quietFrom = fromHour * 60 + fromMin;
  const quietTo = toHour * 60 + toMin;

  // Handle overnight quiet hours (e.g., 22:00 to 08:00)
  if (quietFrom > quietTo) {
    return currentTime >= quietFrom || currentTime <= quietTo;
  }
  
  return currentTime >= quietFrom && currentTime <= quietTo;
}

/**
 * Check for duplicate emails
 */
async function checkDuplicateEmail(userId, type, subject, windowMinutes = 60) {
  const { data } = await supabase
    .rpc('is_duplicate_email', {
      p_user_id: userId,
      p_type: type,
      p_subject: subject,
      p_window_minutes: windowMinutes
    });
  
  return data || false;
}

/**
 * Log email attempt
 */
async function logEmail(userId, type, subject, status, errorText = null, providerResponse = null, recipientEmail = null) {
  await supabase
    .from('email_log')
    .insert({
      user_id: userId,
      recipient_email: recipientEmail,
      type,
      subject,
      status,
      error_text: errorText,
      provider_response: providerResponse,
      attempts: 1
    });
}

/**
 * Get email template
 */
function getTemplate(type, data) {
  const templates = {
    'order_updates': emailTemplates.orderUpdate,
    'billing_updates': emailTemplates.billingUpdate,
    'security_alerts': emailTemplates.securityAlert,
    'marketing': emailTemplates.marketing
  };

  return templates[type] ? templates[type](data) : { subject: '', html: '' };
}

/**
 * Queue notification for digest
 */
async function queueForDigest(userId, type, subject, data, digestMode) {
  // TODO: Implement digest queue
  // Store in a separate table for later batch processing
  console.log(`Queued for ${digestMode} digest:`, { userId, type, subject });
}

/**
 * Helper function to send order update notification
 */
export async function notifyOrderUpdate(userId, orderId, status, message) {
  return await sendNotification({
    userId,
    type: 'order_updates',
    subject: `تحديث الطلب #${orderId}`,
    data: { orderId, status, message }
  });
}

/**
 * Helper function to send billing notification
 */
export async function notifyBilling(userId, amount, invoiceId) {
  return await sendNotification({
    userId,
    type: 'billing_updates',
    subject: `فاتورة جديدة #${invoiceId}`,
    data: { amount, invoiceId }
  });
}

/**
 * Helper function to send security alert
 */
export async function notifySecurityAlert(userId, action, ipAddress) {
  return await sendNotification({
    userId,
    type: 'security_alerts',
    subject: '⚠️ تنبيه أمني',
    data: { 
      action, 
      ipAddress, 
      timestamp: new Date().toLocaleString('ar-SA') 
    }
  });
}
```

## Usage Examples

```javascript
// In your order service
import { notifyOrderUpdate } from '../services/notificationService';

async function updateOrderStatus(orderId, newStatus) {
  // Update order in database
  const { data: order } = await supabase
    .from('orders')
    .update({ status: newStatus })
    .eq('id', orderId)
    .select()
    .single();

  // Send notification
  await notifyOrderUpdate(
    order.user_id,
    orderId,
    newStatus,
    'تم تحديث حالة طلبك بنجاح'
  );
}

// In your payment service
import { notifyBilling } from '../services/notificationService';

async function createInvoice(userId, amount) {
  const invoice = await createInvoiceInDB(userId, amount);
  
  await notifyBilling(userId, amount, invoice.id);
}

// In your auth service
import { notifySecurityAlert } from '../services/notificationService';

async function onSuspiciousLogin(userId, ipAddress) {
  await notifySecurityAlert(userId, 'تسجيل دخول من موقع جديد', ipAddress);
}
```

## Tasks / Subtasks
- [ ] Create notification service module
- [ ] Implement preference checking logic
- [ ] Implement quiet hours logic
- [ ] Implement duplicate detection
- [ ] Create helper functions for each notification type
- [ ] Add error handling and logging
- [ ] Implement digest queue (optional)
- [ ] Create unit tests
- [ ] Create integration tests
- [ ] Document API usage

## Dev Notes
- **Security alerts** should always be sent immediately, ignoring quiet hours and digest mode
- Consider implementing a notification queue for high-volume scenarios
- Add retry logic for failed sends (exponential backoff)
- Monitor email delivery rates and adjust logic as needed
- Consider implementing webhook handlers for delivery status updates

## Testing Checklist
- [ ] Email not sent when globally disabled
- [ ] Email not sent when type disabled
- [ ] Email not sent during quiet hours (except security)
- [ ] Duplicate emails prevented
- [ ] Security alerts always sent immediately
- [ ] Digest mode queues non-urgent emails
- [ ] All attempts logged correctly
- [ ] Error handling works correctly
- [ ] Helper functions work as expected

## Dependencies
- Story 12.1 (Notification Preferences Schema)
- Story 12.2 (Email Delivery Logging)
- Story 12.3 (Zoho SMTP Integration)
