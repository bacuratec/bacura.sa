## Status
To Do

## Story
**As a** developer,
**I want** RESTful API endpoints for notification preferences,
**so that** the frontend can manage user preferences easily.

## Acceptance Criteria
1. GET endpoint to fetch user preferences
2. PUT endpoint to update/upsert preferences
3. JWT authentication required
4. Proper error handling
5. Input validation
6. Rate limiting
7. API documentation

## API Endpoints

### 1. GET User Notification Preferences

**Endpoint**: `GET /api/me/notification-preferences`

**Authentication**: Required (JWT)

**Response**: 200 OK
```json
{
  "success": true,
  "data": {
    "user_id": "uuid",
    "email_enabled": true,
    "order_updates": true,
    "billing_updates": true,
    "security_alerts": true,
    "marketing": false,
    "digest_mode": "immediate",
    "quiet_hours_from": "22:00",
    "quiet_hours_to": "08:00",
    "updated_at": "2026-01-06T10:00:00Z"
  }
}
```

**Response**: 404 Not Found (First time user)
```json
{
  "success": false,
  "error": "Preferences not found",
  "code": "PREFERENCES_NOT_FOUND"
}
```

### 2. PUT Update Notification Preferences

**Endpoint**: `PUT /api/me/notification-preferences`

**Authentication**: Required (JWT)

**Request Body**:
```json
{
  "email_enabled": true,
  "order_updates": true,
  "billing_updates": false,
  "marketing": true,
  "digest_mode": "daily",
  "quiet_hours_from": "23:00",
  "quiet_hours_to": "07:00"
}
```

**Response**: 200 OK
```json
{
  "success": true,
  "message": "Preferences updated successfully",
  "data": {
    "user_id": "uuid",
    "email_enabled": true,
    "order_updates": true,
    "billing_updates": false,
    "security_alerts": true,
    "marketing": true,
    "digest_mode": "daily",
    "quiet_hours_from": "23:00",
    "quiet_hours_to": "07:00",
    "updated_at": "2026-01-06T10:30:00Z"
  }
}
```

**Response**: 400 Bad Request
```json
{
  "success": false,
  "error": "Invalid digest_mode",
  "code": "VALIDATION_ERROR",
  "details": {
    "field": "digest_mode",
    "message": "Must be one of: immediate, daily, weekly"
  }
}
```

### 3. GET Email Sending Status (Helper)

**Endpoint**: `GET /api/notifications/can-send`

**Authentication**: Required (JWT or Service Role)

**Query Parameters**:
- `type`: Notification type (order_updates, billing_updates, etc.)

**Response**: 200 OK
```json
{
  "success": true,
  "can_send": true,
  "reason": null
}
```

**Response**: 200 OK (Cannot send)
```json
{
  "success": true,
  "can_send": false,
  "reason": "email_disabled"
}
```

## Implementation

### Express.js Routes

```javascript
// routes/notificationRoutes.js
import express from 'express';
import { 
  getNotificationPreferences, 
  updateNotificationPreferences,
  checkCanSendEmail 
} from '../controllers/notificationController.js';
import { authenticateUser } from '../middleware/auth.js';
import { validatePreferences } from '../middleware/validation.js';
import { rateLimiter } from '../middleware/rateLimiter.js';

const router = express.Router();

// All routes require authentication
router.use(authenticateUser);

// GET user preferences
router.get('/me/notification-preferences', getNotificationPreferences);

// PUT update preferences (with validation and rate limiting)
router.put(
  '/me/notification-preferences',
  rateLimiter({ max: 10, windowMs: 60000 }), // 10 requests per minute
  validatePreferences,
  updateNotificationPreferences
);

// Helper endpoint to check if email can be sent
router.get('/notifications/can-send', checkCanSendEmail);

export default router;
```

### Controller Implementation

```javascript
// controllers/notificationController.js
import { supabase } from '../lib/supabaseClient.js';

/**
 * GET /api/me/notification-preferences
 * Fetch user's notification preferences
 */
export async function getNotificationPreferences(req, res) {
  try {
    const userId = req.user.id; // From JWT middleware

    const { data, error } = await supabase
      .from('notification_preferences')
      .select('*')
      .eq('user_id', userId)
      .single();

    if (error && error.code === 'PGRST116') {
      // No preferences found - create default
      const { data: newPrefs, error: createError } = await supabase
        .from('notification_preferences')
        .insert({ user_id: userId })
        .select()
        .single();

      if (createError) {
        throw createError;
      }

      return res.status(200).json({
        success: true,
        data: newPrefs,
        is_new: true
      });
    }

    if (error) {
      throw error;
    }

    return res.status(200).json({
      success: true,
      data,
      is_new: false
    });

  } catch (error) {
    console.error('Error fetching preferences:', error);
    return res.status(500).json({
      success: false,
      error: 'Failed to fetch preferences',
      code: 'INTERNAL_ERROR'
    });
  }
}

/**
 * PUT /api/me/notification-preferences
 * Update user's notification preferences (upsert)
 */
export async function updateNotificationPreferences(req, res) {
  try {
    const userId = req.user.id;
    const updates = req.body;

    // Security: Always keep security_alerts enabled
    const safeUpdates = {
      ...updates,
      security_alerts: true, // Force security alerts ON
      user_id: userId,
      updated_at: new Date().toISOString()
    };

    const { data, error } = await supabase
      .from('notification_preferences')
      .upsert(safeUpdates, {
        onConflict: 'user_id',
        returning: 'representation'
      })
      .select()
      .single();

    if (error) {
      throw error;
    }

    return res.status(200).json({
      success: true,
      message: 'Preferences updated successfully',
      data
    });

  } catch (error) {
    console.error('Error updating preferences:', error);
    return res.status(500).json({
      success: false,
      error: 'Failed to update preferences',
      code: 'INTERNAL_ERROR'
    });
  }
}

/**
 * GET /api/notifications/can-send
 * Check if email can be sent to user
 */
export async function checkCanSendEmail(req, res) {
  try {
    const userId = req.user.id;
    const { type } = req.query;

    if (!type) {
      return res.status(400).json({
        success: false,
        error: 'type parameter is required',
        code: 'MISSING_PARAMETER'
      });
    }

    const { data: preferences } = await supabase
      .from('notification_preferences')
      .select('*')
      .eq('user_id', userId)
      .single();

    if (!preferences) {
      return res.status(200).json({
        success: true,
        can_send: true,
        reason: null
      });
    }

    // Check if email is globally enabled
    if (!preferences.email_enabled) {
      return res.status(200).json({
        success: true,
        can_send: false,
        reason: 'email_disabled'
      });
    }

    // Check if specific type is enabled
    const typeMapping = {
      'order_updates': preferences.order_updates,
      'billing_updates': preferences.billing_updates,
      'security_alerts': preferences.security_alerts,
      'marketing': preferences.marketing
    };

    if (!typeMapping[type]) {
      return res.status(200).json({
        success: true,
        can_send: false,
        reason: 'type_disabled'
      });
    }

    return res.status(200).json({
      success: true,
      can_send: true,
      reason: null
    });

  } catch (error) {
    console.error('Error checking send status:', error);
    return res.status(500).json({
      success: false,
      error: 'Failed to check send status',
      code: 'INTERNAL_ERROR'
    });
  }
}
```

### Validation Middleware

```javascript
// middleware/validation.js
export function validatePreferences(req, res, next) {
  const { 
    email_enabled, 
    order_updates, 
    billing_updates, 
    marketing, 
    digest_mode,
    quiet_hours_from,
    quiet_hours_to
  } = req.body;

  // Validate boolean fields
  const booleanFields = {
    email_enabled,
    order_updates,
    billing_updates,
    marketing
  };

  for (const [field, value] of Object.entries(booleanFields)) {
    if (value !== undefined && typeof value !== 'boolean') {
      return res.status(400).json({
        success: false,
        error: `${field} must be a boolean`,
        code: 'VALIDATION_ERROR',
        details: { field }
      });
    }
  }

  // Validate digest_mode
  if (digest_mode && !['immediate', 'daily', 'weekly'].includes(digest_mode)) {
    return res.status(400).json({
      success: false,
      error: 'Invalid digest_mode',
      code: 'VALIDATION_ERROR',
      details: {
        field: 'digest_mode',
        message: 'Must be one of: immediate, daily, weekly'
      }
    });
  }

  // Validate quiet hours format (HH:MM)
  const timeRegex = /^([0-1][0-9]|2[0-3]):[0-5][0-9]$/;
  
  if (quiet_hours_from && !timeRegex.test(quiet_hours_from)) {
    return res.status(400).json({
      success: false,
      error: 'Invalid quiet_hours_from format',
      code: 'VALIDATION_ERROR',
      details: {
        field: 'quiet_hours_from',
        message: 'Must be in HH:MM format (24-hour)'
      }
    });
  }

  if (quiet_hours_to && !timeRegex.test(quiet_hours_to)) {
    return res.status(400).json({
      success: false,
      error: 'Invalid quiet_hours_to format',
      code: 'VALIDATION_ERROR',
      details: {
        field: 'quiet_hours_to',
        message: 'Must be in HH:MM format (24-hour)'
      }
    });
  }

  next();
}
```

### Authentication Middleware

```javascript
// middleware/auth.js
import jwt from 'jsonwebtoken';
import { supabase } from '../lib/supabaseClient.js';

export async function authenticateUser(req, res, next) {
  try {
    const authHeader = req.headers.authorization;

    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({
        success: false,
        error: 'Missing or invalid authorization header',
        code: 'UNAUTHORIZED'
      });
    }

    const token = authHeader.substring(7);

    // Verify JWT with Supabase
    const { data: { user }, error } = await supabase.auth.getUser(token);

    if (error || !user) {
      return res.status(401).json({
        success: false,
        error: 'Invalid or expired token',
        code: 'UNAUTHORIZED'
      });
    }

    // Attach user to request
    req.user = user;
    next();

  } catch (error) {
    console.error('Authentication error:', error);
    return res.status(401).json({
      success: false,
      error: 'Authentication failed',
      code: 'UNAUTHORIZED'
    });
  }
}
```

### Rate Limiter Middleware

```javascript
// middleware/rateLimiter.js
import rateLimit from 'express-rate-limit';

export function rateLimiter(options = {}) {
  return rateLimit({
    windowMs: options.windowMs || 60000, // 1 minute
    max: options.max || 10, // 10 requests per window
    message: {
      success: false,
      error: 'Too many requests, please try again later',
      code: 'RATE_LIMIT_EXCEEDED'
    },
    standardHeaders: true,
    legacyHeaders: false,
  });
}
```

### Main App Setup

```javascript
// app.js
import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import notificationRoutes from './routes/notificationRoutes.js';

const app = express();

// Middleware
app.use(helmet());
app.use(cors());
app.use(express.json());

// Routes
app.use('/api', notificationRoutes);

// Error handler
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({
    success: false,
    error: 'Internal server error',
    code: 'INTERNAL_ERROR'
  });
});

const PORT = process.env.PORT || 3001;
app.listen(PORT, () => {
  console.log(`API server running on port ${PORT}`);
});

export default app;
```

## Frontend Integration

### API Client

```javascript
// src/api/notificationApi.js
import { supabase } from '../lib/supabaseClient';

const API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:3001/api';

async function getAuthToken() {
  const { data: { session } } = await supabase.auth.getSession();
  return session?.access_token;
}

export async function fetchNotificationPreferences() {
  const token = await getAuthToken();
  
  const response = await fetch(`${API_BASE_URL}/me/notification-preferences`, {
    headers: {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    }
  });

  if (!response.ok) {
    throw new Error('Failed to fetch preferences');
  }

  return await response.json();
}

export async function updateNotificationPreferences(preferences) {
  const token = await getAuthToken();
  
  const response = await fetch(`${API_BASE_URL}/me/notification-preferences`, {
    method: 'PUT',
    headers: {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(preferences)
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.error || 'Failed to update preferences');
  }

  return await response.json();
}
```

## Tasks / Subtasks
- [ ] Set up Express.js server
- [ ] Create route handlers
- [ ] Implement authentication middleware
- [ ] Implement validation middleware
- [ ] Implement rate limiting
- [ ] Add error handling
- [ ] Create API documentation (Swagger/OpenAPI)
- [ ] Write unit tests for endpoints
- [ ] Write integration tests
- [ ] Deploy API server

## Dev Notes
- Use environment variables for configuration
- Implement proper CORS settings
- Add request logging for debugging
- Use helmet for security headers
- Implement API versioning (v1, v2, etc.)
- Consider using API Gateway for production

## Testing Checklist
- [ ] GET preferences returns correct data
- [ ] GET preferences creates default for new users
- [ ] PUT preferences validates input
- [ ] PUT preferences enforces security_alerts=true
- [ ] Authentication middleware blocks unauthorized requests
- [ ] Rate limiting works correctly
- [ ] Error responses are consistent
- [ ] CORS configured correctly

## Dependencies
- express
- cors
- helmet
- express-rate-limit
- jsonwebtoken
- @supabase/supabase-js

## API Documentation (Swagger)

```yaml
openapi: 3.0.0
info:
  title: Bacura Notification API
  version: 1.0.0
paths:
  /api/me/notification-preferences:
    get:
      summary: Get user notification preferences
      security:
        - bearerAuth: []
      responses:
        '200':
          description: Success
    put:
      summary: Update notification preferences
      security:
        - bearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/NotificationPreferences'
      responses:
        '200':
          description: Success
```
