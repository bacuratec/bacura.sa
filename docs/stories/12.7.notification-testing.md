## Status
To Do

## Story
**As a** developer,
**I want** comprehensive tests for the notification system,
**so that** I can ensure reliability and prevent regressions.

## Acceptance Criteria
1. Unit tests for notification service
2. Integration tests for email sending
3. Tests for preference checking logic
4. Tests for quiet hours logic
5. Tests for duplicate detection
6. Mock SMTP for testing
7. Test coverage > 80%

## Test Setup

### Install Testing Dependencies
```bash
npm install --save-dev jest @testing-library/react @testing-library/jest-dom
npm install --save-dev nodemailer-mock
npm install --save-dev @supabase/supabase-js
```

### Jest Configuration
```javascript
// jest.config.js
module.exports = {
  testEnvironment: 'node',
  coverageDirectory: 'coverage',
  collectCoverageFrom: [
    'src/services/**/*.js',
    'src/templates/**/*.js',
    '!src/**/*.test.js'
  ],
  setupFilesAfterEnv: ['<rootDir>/tests/setup.js'],
  testMatch: ['**/__tests__/**/*.js', '**/?(*.)+(spec|test).js']
};
```

## Unit Tests

### Test Notification Service
```javascript
// src/services/__tests__/notificationService.test.js
import { sendNotification, notifyOrderUpdate } from '../notificationService';
import { supabase } from '../../lib/supabaseClient';
import { sendEmail } from '../emailService';

// Mock dependencies
jest.mock('../../lib/supabaseClient');
jest.mock('../emailService');

describe('NotificationService', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('sendNotification', () => {
    it('should not send email when email_enabled is false', async () => {
      // Mock preferences with email disabled
      supabase.from.mockReturnValue({
        select: jest.fn().mockReturnValue({
          eq: jest.fn().mockReturnValue({
            single: jest.fn().mockResolvedValue({
              data: { email_enabled: false },
              error: null
            })
          })
        })
      });

      const result = await sendNotification({
        userId: 'user-123',
        type: 'order_updates',
        subject: 'Test',
        data: {}
      });

      expect(result.success).toBe(false);
      expect(result.reason).toBe('email_disabled');
      expect(sendEmail).not.toHaveBeenCalled();
    });

    it('should not send email when notification type is disabled', async () => {
      supabase.from.mockReturnValue({
        select: jest.fn().mockReturnValue({
          eq: jest.fn().mockReturnValue({
            single: jest.fn().mockResolvedValue({
              data: {
                email_enabled: true,
                order_updates: false
              },
              error: null
            })
          })
        })
      });

      const result = await sendNotification({
        userId: 'user-123',
        type: 'order_updates',
        subject: 'Test',
        data: {}
      });

      expect(result.success).toBe(false);
      expect(result.reason).toBe('type_disabled');
    });

    it('should send email when all conditions are met', async () => {
      // Mock preferences
      supabase.from.mockImplementation((table) => {
        if (table === 'notification_preferences') {
          return {
            select: jest.fn().mockReturnValue({
              eq: jest.fn().mockReturnValue({
                single: jest.fn().mockResolvedValue({
                  data: {
                    email_enabled: true,
                    order_updates: true,
                    digest_mode: 'immediate',
                    quiet_hours_from: null,
                    quiet_hours_to: null
                  },
                  error: null
                })
              })
            })
          };
        }
        if (table === 'profiles') {
          return {
            select: jest.fn().mockReturnValue({
              eq: jest.fn().mockReturnValue({
                single: jest.fn().mockResolvedValue({
                  data: {
                    email: 'test@example.com',
                    full_name: 'Test User'
                  },
                  error: null
                })
              })
            })
          };
        }
      });

      // Mock duplicate check
      supabase.rpc = jest.fn().mockResolvedValue({ data: false });

      // Mock email sending
      sendEmail.mockResolvedValue({
        success: true,
        messageId: 'msg-123'
      });

      const result = await sendNotification({
        userId: 'user-123',
        type: 'order_updates',
        subject: 'Test Order Update',
        data: { orderId: '456', status: 'completed' }
      });

      expect(result.success).toBe(true);
      expect(sendEmail).toHaveBeenCalled();
    });

    it('should skip email during quiet hours', async () => {
      const now = new Date();
      const quietFrom = new Date(now);
      quietFrom.setHours(now.getHours() - 1);
      const quietTo = new Date(now);
      quietTo.setHours(now.getHours() + 1);

      supabase.from.mockReturnValue({
        select: jest.fn().mockReturnValue({
          eq: jest.fn().mockReturnValue({
            single: jest.fn().mockResolvedValue({
              data: {
                email_enabled: true,
                order_updates: true,
                quiet_hours_from: quietFrom.toTimeString().slice(0, 5),
                quiet_hours_to: quietTo.toTimeString().slice(0, 5)
              },
              error: null
            })
          })
        })
      });

      const result = await sendNotification({
        userId: 'user-123',
        type: 'order_updates',
        subject: 'Test',
        data: {}
      });

      expect(result.success).toBe(false);
      expect(result.reason).toBe('quiet_hours');
    });

    it('should always send security alerts even during quiet hours', async () => {
      const now = new Date();
      const quietFrom = new Date(now);
      quietFrom.setHours(now.getHours() - 1);
      const quietTo = new Date(now);
      quietTo.setHours(now.getHours() + 1);

      supabase.from.mockImplementation((table) => {
        if (table === 'notification_preferences') {
          return {
            select: jest.fn().mockReturnValue({
              eq: jest.fn().mockReturnValue({
                single: jest.fn().mockResolvedValue({
                  data: {
                    email_enabled: true,
                    security_alerts: true,
                    digest_mode: 'immediate',
                    quiet_hours_from: quietFrom.toTimeString().slice(0, 5),
                    quiet_hours_to: quietTo.toTimeString().slice(0, 5)
                  },
                  error: null
                })
              })
            })
          };
        }
        if (table === 'profiles') {
          return {
            select: jest.fn().mockReturnValue({
              eq: jest.fn().mockReturnValue({
                single: jest.fn().mockResolvedValue({
                  data: {
                    email: 'test@example.com',
                    full_name: 'Test User'
                  },
                  error: null
                })
              })
            })
          };
        }
      });

      supabase.rpc = jest.fn().mockResolvedValue({ data: false });
      sendEmail.mockResolvedValue({ success: true, messageId: 'msg-123' });

      const result = await sendNotification({
        userId: 'user-123',
        type: 'security_alerts',
        subject: 'Security Alert',
        data: { action: 'login', ipAddress: '1.2.3.4' }
      });

      expect(result.success).toBe(true);
      expect(sendEmail).toHaveBeenCalled();
    });
  });

  describe('Helper Functions', () => {
    it('notifyOrderUpdate should call sendNotification with correct params', async () => {
      const sendNotificationSpy = jest.spyOn(
        require('../notificationService'),
        'sendNotification'
      );

      await notifyOrderUpdate('user-123', 'order-456', 'completed', 'Order completed');

      expect(sendNotificationSpy).toHaveBeenCalledWith({
        userId: 'user-123',
        type: 'order_updates',
        subject: expect.stringContaining('order-456'),
        data: {
          orderId: 'order-456',
          status: 'completed',
          message: 'Order completed'
        }
      });
    });
  });
});
```

### Test Email Service
```javascript
// src/services/__tests__/emailService.test.js
import { sendEmail } from '../emailService';
import nodemailer from 'nodemailer';

jest.mock('nodemailer');

describe('EmailService', () => {
  let mockSendMail;

  beforeEach(() => {
    mockSendMail = jest.fn();
    nodemailer.createTransport.mockReturnValue({
      sendMail: mockSendMail,
      verify: jest.fn().mockResolvedValue(true)
    });
  });

  it('should send email successfully', async () => {
    mockSendMail.mockResolvedValue({
      messageId: 'msg-123',
      response: '250 OK',
      accepted: ['test@example.com'],
      rejected: []
    });

    const result = await sendEmail({
      to: 'test@example.com',
      subject: 'Test Email',
      html: '<p>Test content</p>'
    });

    expect(result.success).toBe(true);
    expect(result.messageId).toBe('msg-123');
    expect(mockSendMail).toHaveBeenCalledWith(
      expect.objectContaining({
        to: 'test@example.com',
        subject: 'Test Email'
      })
    );
  });

  it('should handle email sending errors', async () => {
    mockSendMail.mockRejectedValue(new Error('SMTP connection failed'));

    const result = await sendEmail({
      to: 'test@example.com',
      subject: 'Test Email',
      html: '<p>Test content</p>'
    });

    expect(result.success).toBe(false);
    expect(result.error).toBe('SMTP connection failed');
  });

  it('should generate plain text from HTML', async () => {
    mockSendMail.mockResolvedValue({
      messageId: 'msg-123',
      accepted: ['test@example.com']
    });

    await sendEmail({
      to: 'test@example.com',
      subject: 'Test',
      html: '<h1>Hello</h1><p>World</p>'
    });

    expect(mockSendMail).toHaveBeenCalledWith(
      expect.objectContaining({
        text: expect.stringContaining('Hello')
      })
    );
  });
});
```

## Integration Tests

```javascript
// src/services/__tests__/notification.integration.test.js
import { supabase } from '../../lib/supabaseClient';
import { sendNotification } from '../notificationService';

describe('Notification Integration Tests', () => {
  let testUserId;

  beforeAll(async () => {
    // Create test user
    const { data: user } = await supabase.auth.signUp({
      email: 'test@example.com',
      password: 'testpass123'
    });
    testUserId = user.user.id;
  });

  afterAll(async () => {
    // Cleanup
    await supabase.from('notification_preferences').delete().eq('user_id', testUserId);
    await supabase.from('email_log').delete().eq('user_id', testUserId);
  });

  it('should create default preferences for new user', async () => {
    const { data } = await supabase
      .from('notification_preferences')
      .select('*')
      .eq('user_id', testUserId)
      .single();

    expect(data).toBeDefined();
    expect(data.email_enabled).toBe(true);
    expect(data.order_updates).toBe(true);
  });

  it('should log email attempts', async () => {
    await sendNotification({
      userId: testUserId,
      type: 'order_updates',
      subject: 'Test Order',
      data: { orderId: '123' }
    });

    const { data: logs } = await supabase
      .from('email_log')
      .select('*')
      .eq('user_id', testUserId);

    expect(logs.length).toBeGreaterThan(0);
    expect(logs[0].type).toBe('order_updates');
  });
});
```

## E2E Tests

```javascript
// tests/e2e/notifications.test.js
describe('Notification Preferences E2E', () => {
  it('should allow user to update preferences', async () => {
    // Login
    await page.goto('http://localhost:3000/login');
    await page.fill('[name="email"]', 'test@example.com');
    await page.fill('[name="password"]', 'testpass123');
    await page.click('button[type="submit"]');

    // Navigate to preferences
    await page.goto('http://localhost:3000/settings/notifications');

    // Toggle marketing emails
    await page.click('[data-testid="marketing-toggle"]');

    // Save
    await page.click('button:has-text("حفظ التفضيلات")');

    // Verify success message
    await expect(page.locator('text=تم حفظ التفضيلات بنجاح')).toBeVisible();
  });
});
```

## Tasks / Subtasks
- [ ] Set up Jest testing framework
- [ ] Write unit tests for notification service
- [ ] Write unit tests for email service
- [ ] Write integration tests
- [ ] Write E2E tests for UI
- [ ] Set up test coverage reporting
- [ ] Create test fixtures and mocks
- [ ] Document testing procedures
- [ ] Set up CI/CD test pipeline
- [ ] Achieve >80% code coverage

## Dev Notes
- Use `nodemailer-mock` for testing email sending
- Mock Supabase client for unit tests
- Use real database for integration tests (test environment)
- Clean up test data after each test
- Use factories for creating test data
- Test edge cases (null values, errors, etc.)

## Testing Checklist
- [ ] All unit tests pass
- [ ] All integration tests pass
- [ ] E2E tests pass
- [ ] Code coverage >80%
- [ ] Edge cases covered
- [ ] Error handling tested
- [ ] RLS policies tested
- [ ] Performance tests (optional)

## CI/CD Integration

```yaml
# .github/workflows/test.yml
name: Test Notification System

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: '18'
      - run: npm install
      - run: npm test
      - run: npm run test:coverage
      - uses: codecov/codecov-action@v2
```

## Dependencies
- Jest
- @testing-library/react
- nodemailer-mock
- Supabase test environment
